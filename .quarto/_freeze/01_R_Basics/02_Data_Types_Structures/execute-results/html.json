{
  "hash": "38155cbbd50e1b875b47c9c371421dc6",
  "result": {
    "engine": "knitr",
    "markdown": "# Module 1.2: R Data Types and Structures - The Building Blocks\n\n## Introduction: Types and Structures\n\nThink of data like building blocks:\n\n-   **Data Types:** The *kind* of block (e.g., numeric brick, text brick, true/false switch).\n-   **Data Structures:** How you *organize* those blocks (e.g., a single row of bricks, a flat grid, a complex box holding different things).\n\nUnderstanding these is fundamental to working with data in R.\n\n## Basic Data Types\n\nR needs to know what *kind* of information it's dealing with.\n\n1.  **Numeric:** Represents numbers. Can be integers (whole numbers) or doubles (with decimals). Used for measurements like yield, height, counts.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nyield <- 75.5     # Double (decimal)\nnum_plots <- 120  # Integer (whole number)\nclass(yield)      # Check the type\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"numeric\"\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(num_plots)  # Often stored as 'numeric' (double) by default\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"numeric\"\n```\n\n\n:::\n:::\n\n\n\n\n\n\n2.  **Character:** Represents text (strings). Always enclose text in double (`\"`) or single (`'`) quotes. Used for IDs, names, descriptions.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvariety_name <- \"ICARDA_RustResist\"\nplot_id <- 'Plot_A101'\nclass(variety_name)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"character\"\n```\n\n\n:::\n:::\n\n\n\n\n\n\n3.  **Logical:** Represents TRUE or FALSE values. Often the result of comparisons. Crucial for filtering data.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nis_resistant <- TRUE\nyield > 80 # This comparison results in a logical value\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(is_resistant)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"logical\"\n```\n\n\n:::\n:::\n\n\n\n\n\n\n4.  **Factor:** Special type for categorical data (variables with distinct levels or groups). R stores them efficiently using underlying numbers but displays the text labels. Very important for statistical models and plotting.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Example: Different locations in a trial\nlocations <- c(\"Baku\", \"Ganja\", \"Baku\", \"Sheki\", \"Ganja\")\nlocation_factor <- factor(locations)\n\nprint(location_factor) # Shows levels\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] Baku  Ganja Baku  Sheki Ganja\nLevels: Baku Ganja Sheki\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(location_factor)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"factor\"\n```\n\n\n:::\n\n```{.r .cell-code}\nlevels(location_factor) # See the unique categories\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Baku\"  \"Ganja\" \"Sheki\"\n```\n\n\n:::\n:::\n\n\n\n\n\n\n## Key Data Structures\n\nHow R organizes collections of data:\n\n1.  **Vector:** The most basic structure! A sequence (ordered list) containing elements **of the same data type**. Created using `c()` (combine function).\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Vector of plot yields (numeric)\nplot_yields <- c(75.5, 81.2, 78.9, 85.0)\n# Vector of variety names (character)\nplot_varieties <- c(\"ICARDA_Gold\", \"Local_Check\", \"ICARDA_Gold\", \"ICARDA_RustResist\")\n# Vector of resistance status (logical)\nplot_resistance <- c(TRUE, FALSE, TRUE, TRUE)\n\nplot_yields[1]       # Access the first element (Indexing starts at 1!)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 75.5\n```\n\n\n:::\n\n```{.r .cell-code}\nplot_yields[2:4]     # Access elements 2 through 4\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 81.2 78.9 85.0\n```\n\n\n:::\n\n```{.r .cell-code}\nlength(plot_yields)  # Get the number of elements\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4\n```\n\n\n:::\n:::\n\n\n\n\n\n\n*Important:* If you mix types in `c()`, R will force them into a single common type (usually character).\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmixed_vector <- c(10, \"VarietyA\", TRUE)\nprint(mixed_vector) # All become character strings!\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"10\"       \"VarietyA\" \"TRUE\"    \n```\n\n\n:::\n\n```{.r .cell-code}\nclass(mixed_vector)# Example: Small genotype matrix (Individuals x SNPs)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"character\"\n```\n\n\n:::\n:::\n\n\n\n\n\n\n2.  **Matrix:** A two-dimensional grid (rows and columns) where all elements **must be of the same data type**. Useful for genotype data (0,1,2 are all numeric).\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Example: Small genotype matrix (Individuals x SNPs)\n genotype_data <- matrix(c(0, 1, 2, 1, 1, 0), nrow = 2, ncol = 3, byrow = TRUE)\n rownames(genotype_data) <- c(\"Line1\", \"Line2\")\n colnames(genotype_data) <- c(\"SNP1\", \"SNP2\", \"SNP3\")\n print(genotype_data)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      SNP1 SNP2 SNP3\nLine1    0    1    2\nLine2    1    1    0\n```\n\n\n:::\n\n```{.r .cell-code}\n class(genotype_data)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"matrix\" \"array\" \n```\n\n\n:::\n\n```{.r .cell-code}\n dim(genotype_data) # Get dimensions (rows, columns)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2 3\n```\n\n\n:::\n\n```{.r .cell-code}\n genotype_data[1, 2] # Access element row 1, column 2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n```\n\n\n:::\n:::\n\n\n\n\n\n\n3.  **Data Frame:** **The most important data structure for breeders!** Like a spreadsheet or table in R.\n\n    -   It's a collection of vectors (columns) of equal length.\n    -   **Crucially, columns can be of different data types!** (e.g., character ID, numeric yield, factor location).\n    -   Rows represent observations (e.g., plots, plants, samples).\n    -   Columns represent variables (e.g., ID, traits, treatments).\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create a simple breeding trial data frame\ntrial_data <- data.frame(\n PlotID = c(\"A101\", \"A102\", \"B101\", \"B102\"),\n Variety = factor(c(\"ICARDA_Gold\", \"Local_Check\", \"ICARDA_RustResist\", \"ICARDA_Gold\")),\n Yield_kg_plot = c(5.2, 4.5, 6.1, 5.5),\n Is_Resistant = c(TRUE, FALSE, TRUE, TRUE)\n)\n\nprint(trial_data)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  PlotID           Variety Yield_kg_plot Is_Resistant\n1   A101       ICARDA_Gold           5.2         TRUE\n2   A102       Local_Check           4.5        FALSE\n3   B101 ICARDA_RustResist           6.1         TRUE\n4   B102       ICARDA_Gold           5.5         TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(trial_data)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"data.frame\"\n```\n\n\n:::\n\n```{.r .cell-code}\nstr(trial_data)       # Structure: Shows types of each column - VERY USEFUL!\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n'data.frame':\t4 obs. of  4 variables:\n $ PlotID       : chr  \"A101\" \"A102\" \"B101\" \"B102\"\n $ Variety      : Factor w/ 3 levels \"ICARDA_Gold\",..: 1 3 2 1\n $ Yield_kg_plot: num  5.2 4.5 6.1 5.5\n $ Is_Resistant : logi  TRUE FALSE TRUE TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nhead(trial_data)      # Show first few rows\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  PlotID           Variety Yield_kg_plot Is_Resistant\n1   A101       ICARDA_Gold           5.2         TRUE\n2   A102       Local_Check           4.5        FALSE\n3   B101 ICARDA_RustResist           6.1         TRUE\n4   B102       ICARDA_Gold           5.5         TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nsummary(trial_data)   # Summary statistics for each column\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    PlotID                       Variety  Yield_kg_plot   Is_Resistant   \n Length:4           ICARDA_Gold      :2   Min.   :4.500   Mode :logical  \n Class :character   ICARDA_RustResist:1   1st Qu.:5.025   FALSE:1        \n Mode  :character   Local_Check      :1   Median :5.350   TRUE :3        \n                                          Mean   :5.325                  \n                                          3rd Qu.:5.650                  \n                                          Max.   :6.100                  \n```\n\n\n:::\n\n```{.r .cell-code}\n# Access columns using $\ntrial_data$Yield_kg_plot\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5.2 4.5 6.1 5.5\n```\n\n\n:::\n\n```{.r .cell-code}\nmean(trial_data$Yield_kg_plot) # Calculate mean of a column\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5.325\n```\n\n\n:::\n:::\n\n\n\n\n\n\n*(We will work extensively with data frames).*\n\n4.  **List:** A very flexible container that can hold *any* collection of R objects (vectors, matrices, data frames, even other lists), and they don't have to be the same type or length. Often used to return complex results from functions.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nanalysis_results <- list(\n   description = \"Yield Trial - Baku 2023\",\n   raw_data = trial_data, # Include the data frame\n   significant_snps = c(\"SNP101\", \"SNP504\"), # A character vector\n   model_parameters = list(threshold = 0.05, method = \"MLM\") # A nested list\n)\nprint(analysis_results$description)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Yield Trial - Baku 2023\"\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(analysis_results$raw_data) # Access the data frame inside the list\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  PlotID           Variety Yield_kg_plot Is_Resistant\n1   A101       ICARDA_Gold           5.2         TRUE\n2   A102       Local_Check           4.5        FALSE\n3   B101 ICARDA_RustResist           6.1         TRUE\n4   B102       ICARDA_Gold           5.5         TRUE\n```\n\n\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}