# defining our threshold
call_rate <- 0.9
# filtering our matrix
filtered_matrix <- matrix[which(rowMeans(!is.na(matrix)) > call_rate),]
# defining our threshold
na_ind <- 0.8
# filtering our matrix
filtered_matrix <- filtered_matrix[,which(colMeans(!is.na(filtered_matrix)) > na_ind)]
# calculating MAF for all markers
mafFreq <- apply(filtered_matrix, 1, function(row) {
row <- row[!is.na(row)]
maf <- sum(row) / (2 * length(row))
maf <- min(maf, 1 - maf)
maf
})
# filtering matrix according to maf
filtered_matrix <- filtered_matrix[mafFreq > 0.01,]
filter <- filterData(matrix, call_rate = 0.9, maf = 0.01, na_ind = 0.8)
which(mafFreq>0.05)
which(mafFreq>0.01)
# considering our n x m matrix with n markers and m individuals
# defining our threshold
call_rate <- 0.9
# filtering our matrix
filtered_matrix <- matrix[which(rowMeans(!is.na(matrix)) > call_rate),]
# defining our threshold
na_ind <- 0.8
# filtering our matrix
filtered_matrix <- filtered_matrix[,which(colMeans(!is.na(filtered_matrix)) > na_ind)]
# calculating MAF for all markers
mafFreq <- apply(filtered_matrix, 1, function(row) {
row <- row[!is.na(row)]
maf <- sum(row) / (2 * length(row))
maf <- min(maf, 1 - maf)
maf
})
# filtering matrix according to maf
filtered_matrix <- filtered_matrix[mafFreq > 0.01,]
filter <- filterData(matrix, call_rate = 0.9, maf = 0.01, na_ind = 0.8)
# considering our n x m matrix with n markers and m individuals
# defining our threshold
call_rate <- 0.9
# filtering our matrix
filtered_matrix <- matrix[which(rowMeans(!is.na(matrix)) > call_rate),]
# defining our threshold
na_ind <- 0.8
# filtering our matrix
filtered_matrix <- filtered_matrix[,which(colMeans(!is.na(filtered_matrix)) > na_ind)]
# calculating MAF for all markers
mafFreq <- apply(filtered_matrix, 1, function(row) {
row <- row[!is.na(row)]
maf <- sum(row) / (2 * length(row))
maf <- min(maf, 1 - maf)
maf
})
# filtering matrix according to maf
filtered_matrix <- filtered_matrix[mafFreq > 0.01,]
filter <- filterData(matrix, call_rate = 0.9, maf = 0.01, na_ind = 0.8)
manual <- matrix
manual <- manual[rowMeans(!is.na(manual)) > 0.9, ]
manual <- manual[, colMeans(!is.na(manual)) > 0.8]
mafFreq <- apply(manual, 1, function(row) {
row <- row[!is.na(row)]
if(length(row) == 0) return(NA)
maf <- sum(row) / (2 * length(row))
min(maf, 1 - maf)
})
manual <- manual[which(!is.na(mafFreq) & mafFreq > 0.01), ]
## Quality control
# matrix is nxm matrix with n markers and m individuals in numeric format
# returns nxm matrix with n individuals and m markers
filterData <- function(matrix, call_rate = NULL, maf = NULL, na_ind = NULL, stats = FALSE){
X <- matrix
if(is.null(maf))
maf = 0
if(is.null(call_rate))
call_rate = 0
if(is.null(na_ind))
na_ind = 0
# starting dimensions
n_start <- nrow(X)
m_start <- ncol(X)
X <- X[rowMeans(!is.na(X)) > call_rate,] #call rate
stats_call_rate <- n_start - nrow(X)
n_after_callrate <- nrow(X)
X <- X[, colMeans(!is.na(X)) > na_ind] #ind missing data
stats_na_ind <- m_start - ncol(X)
mafFreq <- apply(X, 1, function(row) {
row <- row[!is.na(row)]
if(length(row) == 0) return(NA)
maf <- sum(row) / (2 * length(row))
min(maf, 1 - maf)
})
X <- X[which(!is.na(mafFreq) & mafFreq > 0.01), ]
if(stats){
stats_df <- data.frame(
parameter = c("call rate", "na ind", "maf"),
value = c(stats_call_rate, stats_na_ind, stats_maf)
)
return(list(matrix = X, stats = stats_df))
} else {
return(X)
}
}
filter <- filterData(matrix, call_rate = 0.9, maf = 0.01, na_ind = 0.8)
## Quality control
# matrix is nxm matrix with n markers and m individuals in numeric format
# returns nxm matrix with n individuals and m markers
filterData <- function(matrix, call_rate = NULL, maf = NULL, na_ind = NULL, stats = FALSE){
X <- matrix
if(is.null(maf))
maf = 0
if(is.null(call_rate))
call_rate = 0
if(is.null(na_ind))
na_ind = 0
# starting dimensions
n_start <- nrow(X)
m_start <- ncol(X)
X <- X[rowMeans(!is.na(X)) > call_rate,] #call rate
stats_call_rate <- n_start - nrow(X)
n_after_callrate <- nrow(X)
X <- X[, colMeans(!is.na(X)) > na_ind] #ind missing data
stats_na_ind <- m_start - ncol(X)
mafFreq <- apply(X, 1, function(row) {
row <- row[!is.na(row)]
if(length(row) == 0) return(NA)
maf <- sum(row) / (2 * length(row))
min(maf, 1 - maf)
})
stats_maf <- nrow(X) - length(which(!is.na(mafFreq) & mafFreq > 0.01))
X <- X[which(!is.na(mafFreq) & mafFreq > 0.01), ]
if(stats){
stats_df <- data.frame(
parameter = c("call rate", "na ind", "maf"),
value = c(stats_call_rate, stats_na_ind, stats_maf)
)
return(list(matrix = X, stats = stats_df))
} else {
return(X)
}
}
# considering our n x m matrix with n markers and m individuals
# defining our threshold
call_rate <- 0.9
# filtering our matrix
filtered_matrix <- matrix[which(rowMeans(!is.na(matrix)) > call_rate),]
library(here)
source(here("code","setup.R"))
vcf <- read.vcfR(here("data","BarleySubData.vcf"), verbose = FALSE)
# Glimpse vcf
head(vcf)
# Turn into matrix
vcfMatrix <- extract.gt(vcf)
matrix <- read.table(here("data", "BarleyMarkerMatrix.txt"), sep = "\t", header = TRUE, row.names = 1, check.names = FALSE)
# The vcf matrix we obtained can also be turned into this type of format
matrixNum <- vcfToNumericMatrix(vcfMatrix)
# considering our n x m matrix with n markers and m individuals
# defining our threshold
call_rate <- 0.9
# filtering our matrix
filtered_matrix <- matrix[which(rowMeans(!is.na(matrix)) > call_rate),]
# defining our threshold
na_ind <- 0.8
# filtering our matrix
filtered_matrix <- filtered_matrix[,which(colMeans(!is.na(filtered_matrix)) > na_ind)]
# calculating MAF for all markers
mafFreq <- apply(filtered_matrix, 1, function(row) {
row <- row[!is.na(row)]
maf <- sum(row) / (2 * length(row))
maf <- min(maf, 1 - maf)
maf
})
# filtering matrix according to maf
filtered_matrix <- filtered_matrix[mafFreq > 0.01,]
filter <- filterData(matrix, call_rate = 0.9, maf = 0.01, na_ind = 0.8)
View(vcfMatrix)
library(QBMS)
set_qbms_config(url = "https://gigwa.icarda.org:8443/gigwa/", engine = "gigwa")
library(QBMS)
set_qbms_config(url = "https://gigwa.icarda.org:8443/gigwa/", engine = "gigwa")
login_bms()
gigwa_list_dbs()
# Loading QBMS library
library(QBMS)
# Configuring the connection
set_qbms_config(url = "https://gigwa.icarda.org:8443/gigwa/", engine = "gigwa")
# Logging in to the server to access databases
login_gigwa("Tamara", "-Zy2gn5ijQcW!EE")
# Loading QBMS library
library(QBMS)
# Configuring the connection
set_qbms_config(url = "https://gigwa.icarda.org:8443/gigwa/", engine = "gigwa")
login_gigwa("Tamara", "-Zy2gn5ijQcW!EE")
# Configuring the connection
set_qbms_config(url = "https://gigwa.icarda.org:8443/gigwa/", engine = "gigwa")
login_gigwa("Tamara", "-Zy2gn5ijQcW!EE")
View(vcfMatrix)
View(matrix)
View(matrixNum)
library(here)
source(here("code","setup.R"))
vcf <- read.vcfR(here("data","BarleySubData.vcf"), verbose = FALSE)
# Glimpse vcf
head(vcf)
# Turn into matrix
vcfMatrix <- extract.gt(vcf)
matrix <- read.table(here("data", "BarleyMarkerMatrix.txt"), sep = "\t", header = TRUE, row.names = 1, check.names = FALSE)
# The vcf matrix we obtained can also be turned into this type of format
matrixNum <- vcfToNumericMatrix(vcfMatrix)
View(matrix)
# Loading QBMS library
library(QBMS)
# Configuring the connection
set_qbms_config(url = "https://gigwa.icarda.org:8443/gigwa/", engine = "gigwa")
login_gigwa("Tamara", "-Zy2gn5ijQcW!EE")
gigwa_list_dbs()
# To view available projects
gigwa_list_projects()
# Loading QBMS library
library(QBMS)
# Configuring the connection
set_qbms_config(url = "https://gigwa.icarda.org:8443/gigwa/", engine = "gigwa")
login_gigwa("Tamara", "-Zy2gn5ijQcW!EE")
gigwa_list_dbs()
# To set a data base
gigwa_set_db("BarleySubData")
# To view available projects
gigwa_list_projects()
# To set a project
gigwa_set_project("BarleySubData")
# To view available runs
gigwa_list_runs()
# To set a run
gigwa_set_run("Run1")
# Get a list of all samples in the selected run
samples <- gigwa_get_samples()
# Get sequence list
chroms <- gigwa_get_sequences()
# Get markers
markers <- gigwa_get_markers()
# Get a list of all samples in the selected run
samples <- gigwa_get_samples()
# Get sequence list
chroms <- gigwa_get_sequences()
# Get markers
markers <- gigwa_get_markers()
# Get genotypic matrix
marker_matrix <- gigwa_get_allelematrix()
head(marker_matrix)
saveRDS(marker_matrix, file = here("data","BarleyMarkerMatrixQBMS.rds))
View(marker_matrix)
saveRDS(marker_matrix, file = here("data","BarleyMarkerMatrixQBMS.rds"))
library(here)
saveRDS(marker_matrix, file = here("data","BarleyMarkerMatrixQBMS.rds"))
# Glimpse the matrix
head(marker_matrix)
library(here)
source(here("code","setup.R"))
# Importing our genotypic data
matrix <- as.matrix(readRDS(file = here("data","BarleyMarkerMatrix.rds")))
mmatrix <- as.matrix(readRDS(file = here("data","BarleyMarkerMatrixQBMS.rds")))
View(matrix)
View(mmatrix)
rm(mmatrix)
# Importing our genotypic data
raw_matrix <- as.matrix(readRDS(file = here("data","BarleyMarkerMatrix.rds")))
# Filtering
matrix <- filterData(raw_matrix, call_rate = 0.9, maf = 0.01, na_ind = 0.8)
# We transpose our matrix (to have individuals as rows and makers as columns for posterior analyses)
matrix <- t(matrix)
# Calculating kinship matrix
kinshipMat <- kinshipMatrix(matrix)
library(here)
source(here("code","setup.R"))
# Importing our genotypic data
raw_matrix <- as.matrix(readRDS(file = here("data","BarleyMarkerMatrix.rds")))
# Filtering
matrix <- filterData(raw_matrix, call_rate = 0.9, maf = 0.01, na_ind = 0.8)
# We transpose our matrix (to have individuals as rows and makers as columns for posterior analyses)
matrix <- t(matrix)
# Calculating kinship matrix
kinshipMat <- kinshipMatrix(matrix)
View(kinshipMat)
library(here)
source(here("code","setup.R"))
# Importing our genotypic data
raw_matrix <- as.matrix(readRDS(file = here("data","BarleyMarkerMatrix.rds")))
# Filtering
matrix <- filterData(raw_matrix, call_rate = 0.9, maf = 0.01, na_ind = 0.8)
# We transpose our matrix (to have individuals as rows and makers as columns for posterior analyses)
matrix <- t(matrix)
# Calculating kinship matrix
kinshipMat <- kinshipMatrix(matrix, method = "vanRaden", save = FALSE)
# Identifying duplicates by setting a similarity threshold and using the ICARDA package
duplicates <- kinshipDuplicates(matrix, threshold = 0.99, kinship = kinshipMat)
# Identifying duplicates by setting a similarity threshold and using the ICARDA package
duplicates <- kinshipDuplicates(matrix, threshold = 0.99, kinship = kinshipMat)
# Printing output
duplicates
# Identifying duplicates by setting a similarity threshold and using the ICARDA package
duplicates <- kinshipDuplicates(matrix, threshold = 0.99, kinship = kinshipMat)
# Printing potential duplicates
duplicates$potentialDuplicates
# Printing plots
duplicates$plots
# Identifying duplicates by setting a similarity threshold and using the ICARDA package
duplicates <- kinshipDuplicates(matrix, threshold = 0.99, kinship = kinshipMat)
# Printing potential duplicates
duplicates$potentialDuplicates
# Printing plots
duplicates$plots
View(kinshipMat)
library(here)
source(here("code","setup.R"))
# Importing our genotypic data
raw_matrix <- as.matrix(readRDS(file = here("data","BarleyMarkerMatrix.rds")))
# Filtering
matrix <- filterData(raw_matrix, call_rate = 0.9, maf = 0.01, na_ind = 0.8)
# We transpose our matrix (to have individuals as rows and makers as columns for posterior analyses)
matrix <- t(matrix)
# Calculating kinship matrix using ICARDA package
kinshipMat <- kinshipMatrix(matrix, method = "vanRaden", save = FALSE)
# Generating a heatmap from our kinship matrix as an image in our working directory
kinshipHeatmap(kinshipMat)
# Identifying duplicates by setting a similarity threshold and using the ICARDA package
duplicates <- kinshipDuplicates(matrix, threshold = 0.99, kinship = kinshipMat)
# Printing potential duplicates along with their kinship and correlation
duplicates$potentialDuplicates
# Printing histograms with the distribution of diagonal and off-diagonal values
duplicates$plots
filteredMatrix <- kinshipFilter(matrix, duplicates$potentialDuplicates, kinshipMat)
library(here)
source(here("code","setup.R"))
# Importing our genotypic data
raw_matrix <- as.matrix(readRDS(file = here("data","BarleyMarkerMatrix.rds")))
# Filtering
matrix <- filterData(raw_matrix, call_rate = 0.9, maf = 0.01, na_ind = 0.8)
# We transpose our matrix (to have individuals as rows and makers as columns for posterior analyses)
matrix <- t(matrix)
# Calculating kinship matrix using ICARDA package
kinshipMat <- kinshipMatrix(matrix, method = "vanRaden", save = FALSE)
# Generating a heatmap from our kinship matrix as an image in our working directory
kinshipHeatmap(kinshipMat)
# Identifying duplicates by setting a similarity threshold and using the ICARDA package
duplicates <- kinshipDuplicates(matrix, threshold = 0.99, kinship = kinshipMat)
# Printing potential duplicates along with their kinship and correlation
duplicates$potentialDuplicates
# Printing histograms with the distribution of diagonal and off-diagonal values
duplicates$plots
filteredMatrix <- kinshipFilter(matrix, duplicates$potentialDuplicates, kinshipMat)
library(here)
source(here("code","setup.R"))
vcf <- read.vcfR(here("data","BarleySubData.vcf"), verbose = FALSE)
View(vcf)
vcf@fix
vcf@gt
vcf@meta
matrix <- read.table(here("data", "testMatrix.txt"), sep = "\t", header = TRUE, row.names = 1, check.names = FALSE)
vcf@gt <- vcf@gt[,colnames(vcf@gt) %in% colnames(matrix)]
vcf@meta
write.vcf(vcf, file = here("data","testvcf.vcf"))
vcfT <- read.vcfR(here("data","testvcf.vcf"), verbose = FALSE)
View(vcfT)
library(here)
source(here("code","setup.R"))
vcf <- read.vcfR(here("data","Barley.vcf"), verbose = FALSE)
# Glimpse vcf
head(vcf)
# Turn into matrix
vcfMatrix <- extract.gt(vcf)
matrix <- read.table(here("data", "BarleyMatrix.txt"), sep = "\t", header = TRUE, row.names = 1, check.names = FALSE)
# The vcf matrix we obtained can also be turned into this type of format
matrixNum <- vcfToNumericMatrix(vcfMatrix)
vcf <- read.vcfR(here("data","BarleySubData.vcf"), verbose = FALSE)
View(vcf)
View(vcf)
vcf@gt
View(vcf@gt)
matrix <- read.table(here("data", "testMatrix.txt"), sep = "\t", header = TRUE, row.names = 1, check.names = FALSE)
vcf@gt <- vcf@gt[,colnames(vcf@gt) %in% c("FORMAT",colnames(matrix))]
write.vcf(vcf, file = here("data","testvcf.vcf"))
vcfT <- read.vcfR(here("data","testvcf.vcf"), verbose = FALSE)
View(vcfT)
library(here)
source(here("code","setup.R"))
vcf <- read.vcfR(here("data","Barley.vcf"), verbose = FALSE)
# Glimpse vcf
head(vcf)
# Turn into matrix
vcfMatrix <- extract.gt(vcf)
matrix <- read.table(here("data", "BarleyMatrix.txt"), sep = "\t", header = TRUE, row.names = 1, check.names = FALSE)
# The vcf matrix we obtained can also be turned into this type of format
matrixNum <- vcfToNumericMatrix(vcfMatrix)
metadata <- read.table(file = "Data/Barley/Request_Meta.tsv", sep = "\t", header = TRUE)
Coord <- read_excel("Data/Barley/passport with coordinate.xlsx", col_names = T)
Coord$Genotypes <- paste("ICARDA",Coord$Genotypes, sep = "_") #same ID format
names(Coord)[1] <- "Individual"
metadata <- merge(metadata, Coord[, c("Individual","TAXON","LON","LAT")], by="Individual", all.x=TRUE)
met <- metadata[metadata$countryOfOriginCode %in% c("ETH","CHN","TUR"),]
metadata <- read.table(file = "Data/Barley/Request_Meta.tsv", sep = "\t", header = TRUE)
Coord <- read_excel("Data/Barley/passport with coordinate.xlsx", col_names = T)
Coord$Genotypes <- paste("ICARDA",Coord$Genotypes, sep = "_") #same ID format
names(Coord)[1] <- "Individual"
metadata <- merge(metadata, Coord[, c("Individual","TAXON","LON","LAT")], by="Individual", all.x=TRUE)
met <- metadata[metadata$countryOfOriginCode %in% c("ETH", "CHN", "TUR"),]
write_xlsx(met, path = "BarleyMetadata.xlsx")
library(here)
source(here("code","setup.R"))
vcf <- read.vcfR(here("data","Barley.vcf"), verbose = FALSE)
# Glimpse vcf
head(vcf)
# Turn into matrix
vcfMatrix <- extract.gt(vcf)
matrix <- read.table(here("data", "BarleyMatrix.txt"), sep = "\t", header = TRUE, row.names = 1, check.names = FALSE)
# The vcf matrix we obtained can also be turned into this type of format
matrixNum <- vcfToNumericMatrix(vcfMatrix)
# considering our n x m matrix with n markers and m individuals
# defining our threshold
call_rate <- 0.9
# filtering our matrix
filtered_matrix <- matrix[which(rowMeans(!is.na(matrix)) > call_rate),]
# defining our threshold
na_ind <- 0.8
# filtering our matrix
filtered_matrix <- filtered_matrix[,which(colMeans(!is.na(filtered_matrix)) > na_ind)]
# calculating MAF for all markers
mafFreq <- apply(filtered_matrix, 1, function(row) {
row <- row[!is.na(row)]
maf <- sum(row) / (2 * length(row))
maf <- min(maf, 1 - maf)
maf
})
# filtering matrix according to maf
filtered_matrix <- filtered_matrix[mafFreq > 0.01,]
filter <- filterData(matrix, call_rate = 0.9, maf = 0.01, na_ind = 0.8)
library(here)
source(here("code","setup.R"))
# Importing our genotypic data
raw_matrix <- read.table(here("data", "BarleyMatrix.txt"), sep = "\t", header = TRUE, row.names = 1, check.names = FALSE)
# Filtering
matrix <- filterData(raw_matrix, call_rate = 0.9, maf = 0.01, na_ind = 0.8)
# We transpose our matrix (to have individuals as rows and makers as columns for posterior analyses)
matrix <- t(matrix)
# Calculating kinship matrix using ICARDA package
kinshipMat <- kinshipMatrix(matrix, method = "vanRaden", save = FALSE)
# Generating a heatmap from our kinship matrix as an image in our working directory
kinshipHeatmap(kinshipMat)
# Identifying duplicates by setting a similarity threshold and using the ICARDA package
duplicates <- kinshipDuplicates(matrix, threshold = 0.99, kinship = kinshipMat)
# Printing potential duplicates along with their kinship and correlation
duplicates$potentialDuplicates
# Printing histograms with the distribution of diagonal and off-diagonal values
duplicates$plots
filteredMatrix <- kinshipFilter(matrix, duplicates$potentialDuplicates, kinshipMat)
library(here)
source(here("code","setup.R"))
# Importing our genotypic data
raw_matrix <- read.table(here("data", "BarleyMatrix.txt"), sep = "\t", header = TRUE, row.names = 1, check.names = FALSE)
# Filtering
matrix <- filterData(raw_matrix, call_rate = 0.9, maf = 0.01, na_ind = 0.8)
# We transpose our matrix (to have individuals as rows and makers as columns for posterior analyses)
matrix <- t(matrix)
# Calculating kinship matrix using ICARDA package
kinshipMat <- kinshipMatrix(matrix, method = "vanRaden", save = FALSE)
# Generating a heatmap from our kinship matrix as an image in our working directory
kinshipHeatmap(kinshipMat, file = here("output","heatmap.png"))
# Identifying duplicates by setting a similarity threshold and using the ICARDA package
duplicates <- kinshipDuplicates(matrix, threshold = 0.99, kinship = kinshipMat)
# Printing potential duplicates along with their kinship and correlation
duplicates$potentialDuplicates
# Printing histograms with the distribution of diagonal and off-diagonal values
duplicates$plots
filteredMatrix <- kinshipFilter(matrix, duplicates$potentialDuplicates, kinshipMat)
library(here)
source(here("code","setup.R"))
# Importing our genotypic data
raw_matrix <- read.table(here("data", "BarleyMatrix.txt"), sep = "\t", header = TRUE, row.names = 1, check.names = FALSE)
# Filtering
matrix <- filterData(raw_matrix, call_rate = 0.9, maf = 0.01, na_ind = 0.8)
# We transpose our matrix (to have individuals as rows and makers as columns for posterior analyses)
matrix <- t(matrix)
# Calculating kinship matrix using ICARDA package
kinshipMat <- kinshipMatrix(matrix, method = "vanRaden", save = FALSE)
# Generating a heatmap from our kinship matrix as an image in our working directory
kinshipHeatmap(kinshipMat, file = here("output", "figure", "heatmap.png"))
# Identifying duplicates by setting a similarity threshold and using the ICARDA package
duplicates <- kinshipDuplicates(matrix, threshold = 0.99, kinship = kinshipMat)
# Printing potential duplicates along with their kinship and correlation
duplicates$potentialDuplicates
# Printing histograms with the distribution of diagonal and off-diagonal values
duplicates$plots
filteredMatrix <- kinshipFilter(matrix, duplicates$potentialDuplicates, kinshipMat)
library(here)
source(here("code","setup.R"))
# Importing our genotypic data
raw_matrix <- read.table(here("data", "BarleyMatrix.txt"), sep = "\t", header = TRUE, row.names = 1, check.names = FALSE)
# Filtering
matrix <- filterData(raw_matrix, call_rate = 0.9, maf = 0.01, na_ind = 0.8)
# We transpose our matrix (to have individuals as rows and makers as columns for posterior analyses)
matrix <- t(matrix)
# Calculating kinship matrix using ICARDA package
kinshipMat <- kinshipMatrix(matrix, method = "vanRaden", save = FALSE)
# Generating a heatmap from our kinship matrix as an image in our working directory
kinshipHeatmap(kinshipMat, file = here("output", "figures", "heatmap.png"))
# Identifying duplicates by setting a similarity threshold and using the ICARDA package
duplicates <- kinshipDuplicates(matrix, threshold = 0.99, kinship = kinshipMat)
# Printing potential duplicates along with their kinship and correlation
duplicates$potentialDuplicates
# Printing histograms with the distribution of diagonal and off-diagonal values
duplicates$plots
filteredMatrix <- kinshipFilter(matrix, duplicates$potentialDuplicates, kinshipMat)
